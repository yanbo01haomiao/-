 // 1. for里面是 let 的话，输出结果为 6 ——因为let声明在代码块中有效,var声明全局有效，循环中新的i会被旧的代替，导致最后输出的是最后的i， 为10
var a = [];
for (let i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    };
}
a[6]();


// 2. 不存在变量提升，变量一定要在声明后使用，否则报错
// 例如，将打印语句放在前面，变量在后面声明，使用var，let分别测试，前者 undefined， 后者 报错
console.log(varfirst); // undefined
console.log(letsecond); // ReferenceError
var varfirst;
var letsecond;

// 3. 暂时性死区 temporal dead zone, TDZ
// 只要在代码块中使用let命令声明变量，那么变量就绑定了一个区域，不会受到外部影响(无关定义先后顺序)
var tmp = 123;
if(1){
    tmp = 'abc';
    let tmp; // ReferenceError
}
// 拓展：ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。
// 凡是在声明之前就使用这些变量，就会报错。这些超前使用变量的区域就是死区。
// 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

// 4. 不允许重复声明
// let不允许在相同的作用域内重复声明同一个变量，同理也不能在函数中重新声明函数。

// 5. 块级作用域
// 大括号括起来的区域就是代码块，代码块嵌套时，内外层作用域变量不会相互影响。
function f1() {
    let n = 5;
    if(1){
        let n = 10;
    }
    console.log(n); //5
}
// if内的代码块let声明的n不会和外部n相互影响，因此不用管。内层作用域可以定义外层作用域同名变量。

// 6. 块级作用域和函数声明
// ES5中函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。但是ES6明确允许这一做法。
// 并且在块级作用域中的函数声明语句行为类似于 let，块级作用域外不可引用。
// 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
// 函数声明语句
{
    let a = 'secret';
    function f() {
        return a;
    }
}
// 函数表达式
{
    let a = 'secret';
    let f = function f() {
        return a;
    }
}
// 注意：ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。

// 7. const声明一个只读常量，不可重新赋值，声明必须初始化，块级作用域内有效，不可提升，不可重复定义，存在暂时死区
// 补充：ES6中声明变量的方法有：var let function const import class

// 8.全局对象
// 全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。